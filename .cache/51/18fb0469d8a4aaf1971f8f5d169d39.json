{"id":"node_modules/@aws-sdk/util-base64-browser/dist/cjs/index.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/util-base64-browser/package.json","includedInParent":true,"mtime":1599668814074}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toBase64 = exports.fromBase64 = void 0;\nvar alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n    var char = String.fromCharCode(i + start);\n    alphabetByEncoding[char] = i;\n    alphabetByValue[i] = char;\n}\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n    var char = String.fromCharCode(i + start);\n    var index = i + 26;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nfor (var i = 0; i < 10; i++) {\n    alphabetByEncoding[i.toString(10)] = i + 52;\n    var char = i.toString(10);\n    var index = i + 52;\n    alphabetByEncoding[char] = index;\n    alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nfunction fromBase64(input) {\n    var totalByteLength = (input.length / 4) * 3;\n    if (input.substr(-2) === \"==\") {\n        totalByteLength -= 2;\n    }\n    else if (input.substr(-1) === \"=\") {\n        totalByteLength--;\n    }\n    var out = new ArrayBuffer(totalByteLength);\n    var dataView = new DataView(out);\n    for (var i = 0; i < input.length; i += 4) {\n        var bits = 0;\n        var bitLength = 0;\n        for (var j = i, limit = i + 3; j <= limit; j++) {\n            if (input[j] !== \"=\") {\n                bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n                bitLength += bitsPerLetter;\n            }\n            else {\n                bits >>= bitsPerLetter;\n            }\n        }\n        var chunkOffset = (i / 4) * 3;\n        bits >>= bitLength % bitsPerByte;\n        var byteLength = Math.floor(bitLength / bitsPerByte);\n        for (var k = 0; k < byteLength; k++) {\n            var offset = (byteLength - k - 1) * bitsPerByte;\n            dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n        }\n    }\n    return new Uint8Array(out);\n}\nexports.fromBase64 = fromBase64;\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nfunction toBase64(input) {\n    var str = \"\";\n    for (var i = 0; i < input.length; i += 3) {\n        var bits = 0;\n        var bitLength = 0;\n        for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n            bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n            bitLength += bitsPerByte;\n        }\n        var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n        bits <<= bitClusterCount * bitsPerLetter - bitLength;\n        for (var k = 1; k <= bitClusterCount; k++) {\n            var offset = (bitClusterCount - k) * bitsPerLetter;\n            str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n        }\n        str += \"==\".slice(0, 4 - bitClusterCount);\n    }\n    return str;\n}\nexports.toBase64 = toBase64;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const alphabetByEncoding: { [key: string]: number } = {};\nconst alphabetByValue: Array<string> = new Array(64);\n\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\n\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\n\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input: string): Uint8Array {\n  let totalByteLength = (input.length / 4) * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    const chunkOffset = (i / 4) * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n      bitLength += bitsPerByte;\n    }\n\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}\n"]}},"error":null,"hash":"8b8665e00486e37198c2f2071f459a46","cacheData":{"env":{}}}