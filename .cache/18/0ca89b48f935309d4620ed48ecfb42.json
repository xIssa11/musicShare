{"id":"node_modules/@aws-sdk/fetch-http-handler/dist/cjs/fetch-http-handler.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/package.json","includedInParent":true,"mtime":1599668814063},{"name":"tslib","loc":{"line":4,"column":22},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/dist/cjs/fetch-http-handler.js","resolved":"/Users/spittela/code/giphlify/node_modules/tslib/tslib.es6.js"},{"name":"@aws-sdk/protocol-http","loc":{"line":5,"column":30},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/dist/cjs/fetch-http-handler.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/protocol-http/dist/cjs/index.js"},{"name":"@aws-sdk/querystring-builder","loc":{"line":6,"column":36},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/dist/cjs/fetch-http-handler.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/querystring-builder/dist/cjs/index.js"},{"name":"./request-timeout","loc":{"line":7,"column":32},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/dist/cjs/fetch-http-handler.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/fetch-http-handler/dist/cjs/request-timeout.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchHttpHandler = void 0;\nvar tslib_1 = require(\"tslib\");\nvar protocol_http_1 = require(\"@aws-sdk/protocol-http\");\nvar querystring_builder_1 = require(\"@aws-sdk/querystring-builder\");\nvar request_timeout_1 = require(\"./request-timeout\");\nvar FetchHttpHandler = /** @class */ (function () {\n    function FetchHttpHandler(httpOptions) {\n        if (httpOptions === void 0) { httpOptions = {}; }\n        this.httpOptions = httpOptions;\n    }\n    FetchHttpHandler.prototype.destroy = function () {\n        // Do nothing. TLS and HTTP/2 connection pooling is handled by the\n        // browser.\n    };\n    FetchHttpHandler.prototype.handle = function (request, options) {\n        var abortSignal = options === null || options === void 0 ? void 0 : options.abortSignal;\n        var requestTimeoutInMs = this.httpOptions.requestTimeout;\n        // if the request was already aborted, prevent doing extra work\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n            var abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        var path = request.path;\n        if (request.query) {\n            var queryString = querystring_builder_1.buildQueryString(request.query);\n            if (queryString) {\n                path += \"?\" + queryString;\n            }\n        }\n        var port = request.port;\n        var url = request.protocol + \"//\" + request.hostname + (port ? \":\" + port : \"\") + path;\n        var requestOptions = {\n            body: request.body,\n            headers: new Headers(request.headers),\n            method: request.method,\n        };\n        // some browsers support abort signal\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions[\"signal\"] = abortSignal;\n        }\n        var fetchRequest = new Request(url, requestOptions);\n        var raceOfPromises = [\n            fetch(fetchRequest).then(function (response) {\n                var e_1, _a;\n                var fetchHeaders = response.headers;\n                var transformedHeaders = {};\n                try {\n                    for (var _b = tslib_1.__values(fetchHeaders.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var pair = _c.value;\n                        transformedHeaders[pair[0]] = pair[1];\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                var hasReadableStream = response.body !== undefined;\n                // Return the response with buffered body\n                if (!hasReadableStream) {\n                    return response.blob().then(function (body) { return ({\n                        response: new protocol_http_1.HttpResponse({\n                            headers: transformedHeaders,\n                            statusCode: response.status,\n                            body: body,\n                        }),\n                    }); });\n                }\n                // Return the response with streaming body\n                return {\n                    response: new protocol_http_1.HttpResponse({\n                        headers: transformedHeaders,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            request_timeout_1.requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise(function (resolve, reject) {\n                abortSignal.onabort = function () {\n                    var abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n            }));\n        }\n        return Promise.race(raceOfPromises);\n    };\n    return FetchHttpHandler;\n}());\nexports.FetchHttpHandler = FetchHttpHandler;\n"},"sourceMaps":{"js":{"version":3,"file":"fetch-http-handler.js","sourceRoot":"","sources":["../../src/fetch-http-handler.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpHandler, HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { HeaderBag, HttpHandlerOptions } from \"@aws-sdk/types\";\n\nimport { requestTimeout } from \"./request-timeout\";\n\ndeclare let AbortController: any;\n\n/**\n * Represents the http options that can be passed to a browser http client.\n */\nexport interface BrowserHttpOptions {\n  /**\n   * The number of milliseconds a request can take before being automatically\n   * terminated.\n   */\n  requestTimeout?: number;\n}\n\nexport class FetchHttpHandler implements HttpHandler {\n  constructor(private readonly httpOptions: BrowserHttpOptions = {}) {}\n\n  destroy(): void {\n    // Do nothing. TLS and HTTP/2 connection pooling is handled by the\n    // browser.\n  }\n\n  handle(request: HttpRequest, options: HttpHandlerOptions): Promise<{ response: HttpResponse }> {\n    const abortSignal = options?.abortSignal;\n    const requestTimeoutInMs = this.httpOptions.requestTimeout;\n\n    // if the request was already aborted, prevent doing extra work\n    if (abortSignal?.aborted) {\n      const abortError = new Error(\"Request aborted\");\n      abortError.name = \"AbortError\";\n      return Promise.reject(abortError);\n    }\n\n    let path = request.path;\n    if (request.query) {\n      const queryString = buildQueryString(request.query);\n      if (queryString) {\n        path += `?${queryString}`;\n      }\n    }\n\n    const port = request.port;\n    const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n    const requestOptions: RequestInit = {\n      body: request.body,\n      headers: new Headers(request.headers),\n      method: request.method,\n    };\n\n    // some browsers support abort signal\n    if (typeof AbortController !== \"undefined\") {\n      (requestOptions as any)[\"signal\"] = abortSignal;\n    }\n\n    const fetchRequest = new Request(url, requestOptions);\n    const raceOfPromises = [\n      fetch(fetchRequest).then((response) => {\n        const fetchHeaders: any = response.headers;\n        const transformedHeaders: HeaderBag = {};\n\n        for (const pair of <Array<string[]>>fetchHeaders.entries()) {\n          transformedHeaders[pair[0]] = pair[1];\n        }\n\n        const hasReadableStream = response.body !== undefined;\n\n        // Return the response with buffered body\n        if (!hasReadableStream) {\n          return response.blob().then((body) => ({\n            response: new HttpResponse({\n              headers: transformedHeaders,\n              statusCode: response.status,\n              body,\n            }),\n          }));\n        }\n        // Return the response with streaming body\n        return {\n          response: new HttpResponse({\n            headers: transformedHeaders,\n            statusCode: response.status,\n            body: response.body,\n          }),\n        };\n      }),\n      requestTimeout(requestTimeoutInMs),\n    ];\n    if (abortSignal) {\n      raceOfPromises.push(\n        new Promise<never>((resolve, reject) => {\n          abortSignal.onabort = () => {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            reject(abortError);\n          };\n        })\n      );\n    }\n    return Promise.race(raceOfPromises);\n  }\n}\n"]}},"error":null,"hash":"fed60e3aa45a5b7366f1602d1822365b","cacheData":{"env":{}}}