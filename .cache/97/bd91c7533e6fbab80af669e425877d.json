{"id":"node_modules/@aws-sdk/middleware-signing/dist/cjs/configurations.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-signing/package.json","includedInParent":true,"mtime":1599668814062},{"name":"tslib","loc":{"line":4,"column":22},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-signing/dist/cjs/configurations.js","resolved":"/Users/spittela/code/giphlify/node_modules/tslib/tslib.es6.js"},{"name":"@aws-sdk/signature-v4","loc":{"line":5,"column":29},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-signing/dist/cjs/configurations.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/signature-v4/dist/es/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveAwsAuthConfig = void 0;\nvar tslib_1 = require(\"tslib\");\nvar signature_v4_1 = require(\"@aws-sdk/signature-v4\");\nfunction resolveAwsAuthConfig(input) {\n    var _this = this;\n    var credentials = input.credentials || input.credentialDefaultProvider(input);\n    var normalizedCreds = normalizeProvider(credentials);\n    var _a = input.signingEscapePath, signingEscapePath = _a === void 0 ? true : _a, _b = input.systemClockOffset, systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b, sha256 = input.sha256;\n    var signer;\n    if (input.signer) {\n        //if signer is supplied by user, normalize it to a function returning a promise for signer.\n        signer = normalizeProvider(input.signer);\n    }\n    else {\n        //construct a provider inferring signing from region.\n        signer = function () {\n            return normalizeProvider(input.region)()\n                .then(function (region) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, input.regionInfoProvider(region)];\n                    case 1: return [2 /*return*/, [(_a.sent()) || {}, region]];\n                }\n            }); }); })\n                .then(function (_a) {\n                var _b = tslib_1.__read(_a, 2), regionInfo = _b[0], region = _b[1];\n                var _c = regionInfo.signingRegion, signingRegion = _c === void 0 ? input.signingRegion : _c, _d = regionInfo.signingService, signingService = _d === void 0 ? input.signingName : _d;\n                //update client's singing region and signing service config if they are resolved.\n                //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n                input.signingRegion = input.signingRegion || signingRegion || region;\n                input.signingName = input.signingName || signingService;\n                return new signature_v4_1.SignatureV4({\n                    credentials: normalizedCreds,\n                    region: input.signingRegion,\n                    service: input.signingName,\n                    sha256: sha256,\n                    uriEscapePath: signingEscapePath,\n                });\n            });\n        };\n    }\n    return tslib_1.__assign(tslib_1.__assign({}, input), { systemClockOffset: systemClockOffset,\n        signingEscapePath: signingEscapePath, credentials: normalizedCreds, signer: signer });\n}\nexports.resolveAwsAuthConfig = resolveAwsAuthConfig;\nfunction normalizeProvider(input) {\n    if (typeof input === \"object\") {\n        var promisified_1 = Promise.resolve(input);\n        return function () { return promisified_1; };\n    }\n    return input;\n}\n"},"sourceMaps":{"js":{"version":3,"file":"configurations.js","sourceRoot":"","sources":["../../src/configurations.ts"],"names":[],"mappings":";;;;AAAA,sDAAoD;AA2CpD,SAAgB,oBAAoB,CAAI,KAAkD;IAA1F,iBAqCC;IApCC,IAAM,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,KAAK,CAAC,yBAAyB,CAAC,KAAY,CAAC,CAAC;IACvF,IAAM,eAAe,GAAG,iBAAiB,CAAC,WAAW,CAAC,CAAC;IAC/C,IAAA,KAAuF,KAAK,kBAApE,EAAxB,iBAAiB,mBAAG,IAAI,KAAA,EAAE,KAA6D,KAAK,kBAAlB,EAAhD,iBAAiB,mBAAG,KAAK,CAAC,iBAAiB,IAAI,CAAC,KAAA,EAAE,MAAM,GAAK,KAAK,OAAV,CAAW;IACrG,IAAI,MAA+B,CAAC;IACpC,IAAI,KAAK,CAAC,MAAM,EAAE;QAChB,2FAA2F;QAC3F,MAAM,GAAG,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;KAC1C;SAAM;QACL,qDAAqD;QACrD,MAAM,GAAG;YACP,OAAA,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE;iBAC9B,IAAI,CAAC,UAAO,MAAM;;4BAAO,qBAAM,KAAK,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAAA;4BAAxC,sBAAA,CAAC,CAAC,SAAsC,CAAC,IAAI,EAAE,EAAE,MAAM,CAAyB,EAAA;;qBAAA,CAAC;iBACxG,IAAI,CAAC,UAAC,EAAoB;oBAApB,KAAA,qBAAoB,EAAnB,UAAU,QAAA,EAAE,MAAM,QAAA;gBAChB,IAAA,KAA4E,UAAU,cAAnD,EAAnC,aAAa,mBAAG,KAAK,CAAC,aAAa,KAAA,EAAE,KAAuC,UAAU,eAAf,EAAlC,cAAc,mBAAG,KAAK,CAAC,WAAW,KAAA,CAAgB;gBAC/F,iFAAiF;gBACjF,gHAAgH;gBAChH,KAAK,CAAC,aAAa,GAAG,KAAK,CAAC,aAAa,IAAI,aAAa,IAAI,MAAM,CAAC;gBACrE,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,cAAc,CAAC;gBAExD,OAAO,IAAI,0BAAW,CAAC;oBACrB,WAAW,EAAE,eAAe;oBAC5B,MAAM,EAAE,KAAK,CAAC,aAAa;oBAC3B,OAAO,EAAE,KAAK,CAAC,WAAW;oBAC1B,MAAM,QAAA;oBACN,aAAa,EAAE,iBAAiB;iBACjC,CAAC,CAAC;YACL,CAAC,CAAC;QAhBJ,CAgBI,CAAC;KACR;IAED,6CACK,KAAK,KACR,iBAAiB,mBAAA;QACjB,iBAAiB,mBAAA,EACjB,WAAW,EAAE,eAAe,EAC5B,MAAM,QAAA,IACN;AACJ,CAAC;AArCD,oDAqCC;AAED,SAAS,iBAAiB,CAAI,KAAsB;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,IAAM,aAAW,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC3C,OAAO,cAAM,OAAA,aAAW,EAAX,CAAW,CAAC;KAC1B;IACD,OAAO,KAAoB,CAAC;AAC9B,CAAC","sourcesContent":["import { SignatureV4 } from \"@aws-sdk/signature-v4\";\nimport { Credentials, HashConstructor, Provider, RegionInfo, RegionInfoProvider, RequestSigner } from \"@aws-sdk/types\";\n\nexport interface AwsAuthInputConfig {\n  /**\n   * The credentials used to sign requests.\n   */\n  credentials?: Credentials | Provider<Credentials>;\n\n  /**\n   * The signer to use when signing requests.\n   */\n  signer?: RequestSigner | Provider<RequestSigner>;\n\n  /**\n   * Whether to escape request path when signing the request.\n   */\n  signingEscapePath?: boolean;\n\n  /**\n   * An offset value in milliseconds to apply to all signing times.\n   */\n  systemClockOffset?: number;\n\n  /**\n   * The region where you want to sign your request against. This\n   * can be different to the region in the endpoint.\n   */\n  signingRegion?: string;\n}\ninterface PreviouslyResolved {\n  credentialDefaultProvider: (input: any) => Provider<Credentials>;\n  region: string | Provider<string>;\n  regionInfoProvider: RegionInfoProvider;\n  signingName: string;\n  sha256: HashConstructor;\n}\nexport interface AwsAuthResolvedConfig {\n  credentials: Provider<Credentials>;\n  signer: Provider<RequestSigner>;\n  signingEscapePath: boolean;\n  systemClockOffset: number;\n}\nexport function resolveAwsAuthConfig<T>(input: T & AwsAuthInputConfig & PreviouslyResolved): T & AwsAuthResolvedConfig {\n  const credentials = input.credentials || input.credentialDefaultProvider(input as any);\n  const normalizedCreds = normalizeProvider(credentials);\n  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;\n  let signer: Provider<RequestSigner>;\n  if (input.signer) {\n    //if signer is supplied by user, normalize it to a function returning a promise for signer.\n    signer = normalizeProvider(input.signer);\n  } else {\n    //construct a provider inferring signing from region.\n    signer = () =>\n      normalizeProvider(input.region)()\n        .then(async (region) => [(await input.regionInfoProvider(region)) || {}, region] as [RegionInfo, string])\n        .then(([regionInfo, region]) => {\n          const { signingRegion = input.signingRegion, signingService = input.signingName } = regionInfo;\n          //update client's singing region and signing service config if they are resolved.\n          //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region\n          input.signingRegion = input.signingRegion || signingRegion || region;\n          input.signingName = input.signingName || signingService;\n\n          return new SignatureV4({\n            credentials: normalizedCreds,\n            region: input.signingRegion,\n            service: input.signingName,\n            sha256,\n            uriEscapePath: signingEscapePath,\n          });\n        });\n  }\n\n  return {\n    ...input,\n    systemClockOffset,\n    signingEscapePath,\n    credentials: normalizedCreds,\n    signer,\n  };\n}\n\nfunction normalizeProvider<T>(input: T | Provider<T>): Provider<T> {\n  if (typeof input === \"object\") {\n    const promisified = Promise.resolve(input);\n    return () => promisified;\n  }\n  return input as Provider<T>;\n}\n"]}},"error":null,"hash":"f203935c296b4c3ad8c0707e9baeb0df","cacheData":{"env":{}}}