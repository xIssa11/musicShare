{"id":"node_modules/@aws-sdk/property-provider/dist/cjs/chain.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/package.json","includedInParent":true,"mtime":1599668814077},{"name":"tslib","loc":{"line":4,"column":22},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/dist/cjs/chain.js","resolved":"/Users/spittela/code/giphlify/node_modules/tslib/tslib.es6.js"},{"name":"./ProviderError","loc":{"line":5,"column":30},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/dist/cjs/chain.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/dist/cjs/ProviderError.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chain = void 0;\nvar tslib_1 = require(\"tslib\");\nvar ProviderError_1 = require(\"./ProviderError\");\n/**\n * Compose a single credential provider function from multiple credential\n * providers. The first provider in the argument list will always be invoked;\n * subsequent providers in the list will be invoked in the order in which the\n * were received if the preceding provider did not successfully resolve.\n *\n * If no providers were received or no provider resolves successfully, the\n * returned promise will be rejected.\n */\nfunction chain() {\n    var providers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        providers[_i] = arguments[_i];\n    }\n    return function () {\n        var e_1, _a;\n        var promise = Promise.reject(new ProviderError_1.ProviderError(\"No providers in chain\"));\n        var _loop_1 = function (provider) {\n            promise = promise.catch(function (err) {\n                if (err === null || err === void 0 ? void 0 : err.tryNextLink) {\n                    return provider();\n                }\n                throw err;\n            });\n        };\n        try {\n            for (var providers_1 = tslib_1.__values(providers), providers_1_1 = providers_1.next(); !providers_1_1.done; providers_1_1 = providers_1.next()) {\n                var provider = providers_1_1.value;\n                _loop_1(provider);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (providers_1_1 && !providers_1_1.done && (_a = providers_1.return)) _a.call(providers_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return promise;\n    };\n}\nexports.chain = chain;\n"},"sourceMaps":{"js":{"version":3,"file":"chain.js","sourceRoot":"","sources":["../../src/chain.ts"],"names":[],"mappings":";;;;AAEA,iDAAgD;AAEhD;;;;;;;;GAQG;AACH,SAAgB,KAAK;IAAI,mBAAgC;SAAhC,UAAgC,EAAhC,qBAAgC,EAAhC,IAAgC;QAAhC,8BAAgC;;IACvD,OAAO;;QACL,IAAI,OAAO,GAAe,OAAO,CAAC,MAAM,CAAC,IAAI,6BAAa,CAAC,uBAAuB,CAAC,CAAC,CAAC;gCAC1E,QAAQ;YACjB,OAAO,GAAG,OAAO,CAAC,KAAK,CAAC,UAAC,GAAQ;gBAC/B,IAAI,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,WAAW,EAAE;oBACpB,OAAO,QAAQ,EAAE,CAAC;iBACnB;gBAED,MAAM,GAAG,CAAC;YACZ,CAAC,CAAC,CAAC;;;YAPL,KAAuB,IAAA,cAAA,iBAAA,SAAS,CAAA,oCAAA;gBAA3B,IAAM,QAAQ,sBAAA;wBAAR,QAAQ;aAQlB;;;;;;;;;QAED,OAAO,OAAO,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC;AAfD,sBAeC","sourcesContent":["import { Provider } from \"@aws-sdk/types\";\n\nimport { ProviderError } from \"./ProviderError\";\n\n/**\n * Compose a single credential provider function from multiple credential\n * providers. The first provider in the argument list will always be invoked;\n * subsequent providers in the list will be invoked in the order in which the\n * were received if the preceding provider did not successfully resolve.\n *\n * If no providers were received or no provider resolves successfully, the\n * returned promise will be rejected.\n */\nexport function chain<T>(...providers: Array<Provider<T>>): Provider<T> {\n  return () => {\n    let promise: Promise<T> = Promise.reject(new ProviderError(\"No providers in chain\"));\n    for (const provider of providers) {\n      promise = promise.catch((err: any) => {\n        if (err?.tryNextLink) {\n          return provider();\n        }\n\n        throw err;\n      });\n    }\n\n    return promise;\n  };\n}\n"]}},"error":null,"hash":"78a76a3efa0a8ffbbfd05f867b507a70","cacheData":{"env":{}}}