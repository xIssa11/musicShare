{"id":"node_modules/@aws-sdk/property-provider/dist/cjs/memoize.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/package.json","includedInParent":true,"mtime":1599668814077},{"name":"tslib","loc":{"line":4,"column":22},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/property-provider/dist/cjs/memoize.js","resolved":"/Users/spittela/code/giphlify/node_modules/tslib/tslib.es6.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoize = void 0;\nvar tslib_1 = require(\"tslib\");\nexports.memoize = function (provider, isExpired, requiresRefresh) {\n    if (isExpired === undefined) {\n        // This is a static memoization; no need to incorporate refreshing\n        var result_1 = provider();\n        return function () { return result_1; };\n    }\n    var result = provider();\n    var isConstant = false;\n    return function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {\n        var resolved;\n        return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (isConstant) {\n                        return [2 /*return*/, result];\n                    }\n                    return [4 /*yield*/, result];\n                case 1:\n                    resolved = _a.sent();\n                    if (requiresRefresh && !requiresRefresh(resolved)) {\n                        isConstant = true;\n                        return [2 /*return*/, resolved];\n                    }\n                    if (isExpired(resolved)) {\n                        return [2 /*return*/, (result = provider())];\n                    }\n                    return [2 /*return*/, resolved];\n            }\n        });\n    }); };\n};\n"},"sourceMaps":{"js":{"version":3,"file":"memoize.js","sourceRoot":"","sources":["../../src/memoize.ts"],"names":[],"mappings":";;;;AAwCa,QAAA,OAAO,GAAoB,UACtC,QAAqB,EACrB,SAAoC,EACpC,eAA0C;IAE1C,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,kEAAkE;QAClE,IAAM,QAAM,GAAG,QAAQ,EAAE,CAAC;QAC1B,OAAO,cAAM,OAAA,QAAM,EAAN,CAAM,CAAC;KACrB;IAED,IAAI,MAAM,GAAG,QAAQ,EAAE,CAAC;IACxB,IAAI,UAAU,GAAG,KAAK,CAAC;IAEvB,OAAO;;;;;oBACL,IAAI,UAAU,EAAE;wBACd,sBAAO,MAAM,EAAC;qBACf;oBAEgB,qBAAM,MAAM,EAAA;;oBAAvB,QAAQ,GAAG,SAAY;oBAC7B,IAAI,eAAe,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;wBACjD,UAAU,GAAG,IAAI,CAAC;wBAClB,sBAAO,QAAQ,EAAC;qBACjB;oBACD,IAAI,SAAS,CAAC,QAAQ,CAAC,EAAE;wBACvB,sBAAO,CAAC,MAAM,GAAG,QAAQ,EAAE,CAAC,EAAC;qBAC9B;oBACD,sBAAO,QAAQ,EAAC;;;SACjB,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { Provider } from \"@aws-sdk/types\";\n\ninterface MemoizeOverload {\n  /**\n   *\n   * Decorates a provider function with either static memoization.\n   *\n   * To create a statically memoized provider, supply a provider as the only\n   * argument to this function. The provider will be invoked once, and all\n   * invocations of the provider returned by `memoize` will return the same\n   * promise object.\n   *\n   * @param provider The provider whose result should be cached indefinitely.\n   */\n  <T>(provider: Provider<T>): Provider<T>;\n\n  /**\n   * Decorates a provider function with refreshing memoization.\n   *\n   * @param provider          The provider whose result should be cached.\n   * @param isExpired         A function that will evaluate the resolved value and\n   *                          determine if it is expired. For example, when\n   *                          memoizing AWS credential providers, this function\n   *                          should return `true` when the credential's\n   *                          expiration is in the past (or very near future) and\n   *                          `false` otherwise.\n   * @param requiresRefresh   A function that will evaluate the resolved value and\n   *                          determine if it represents static value or one that\n   *                          will eventually need to be refreshed. For example,\n   *                          AWS credentials that have no defined expiration will\n   *                          never need to be refreshed, so this function would\n   *                          return `true` if the credentials resolved by the\n   *                          underlying provider had an expiration and `false`\n   *                          otherwise.\n   */\n  <T>(provider: Provider<T>, isExpired: (resolved: T) => boolean, requiresRefresh?: (resolved: T) => boolean): Provider<\n    T\n  >;\n}\n\nexport const memoize: MemoizeOverload = <T>(\n  provider: Provider<T>,\n  isExpired?: (resolved: T) => boolean,\n  requiresRefresh?: (resolved: T) => boolean\n): Provider<T> => {\n  if (isExpired === undefined) {\n    // This is a static memoization; no need to incorporate refreshing\n    const result = provider();\n    return () => result;\n  }\n\n  let result = provider();\n  let isConstant = false;\n\n  return async () => {\n    if (isConstant) {\n      return result;\n    }\n\n    const resolved = await result;\n    if (requiresRefresh && !requiresRefresh(resolved)) {\n      isConstant = true;\n      return resolved;\n    }\n    if (isExpired(resolved)) {\n      return (result = provider());\n    }\n    return resolved;\n  };\n};\n"]}},"error":null,"hash":"4eba26e308a7f1f44466ad48f00008f4","cacheData":{"env":{}}}