{"id":"node_modules/@aws-sdk/config-resolver/dist/cjs/EndpointsConfig.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/config-resolver/package.json","includedInParent":true,"mtime":1599668814062},{"name":"tslib","loc":{"line":4,"column":22},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/config-resolver/dist/cjs/EndpointsConfig.js","resolved":"/Users/spittela/code/giphlify/node_modules/tslib/tslib.es6.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveEndpointsConfig = exports.normalizeEndpoint = void 0;\nvar tslib_1 = require(\"tslib\");\nfunction normalizeEndpoint(endpoint, urlParser) {\n    if (typeof endpoint === \"string\") {\n        var promisified_1 = Promise.resolve(urlParser(endpoint));\n        return function () { return promisified_1; };\n    }\n    else if (typeof endpoint === \"object\") {\n        var promisified_2 = Promise.resolve(endpoint);\n        return function () { return promisified_2; };\n    }\n    return endpoint;\n}\nexports.normalizeEndpoint = normalizeEndpoint;\nfunction resolveEndpointsConfig(input) {\n    var _this = this;\n    var tls = input.tls === undefined ? true : input.tls;\n    var endpoint = input.endpoint\n        ? normalizeEndpoint(input.endpoint, input.urlParser)\n        : function () {\n            return input.region().then(function (region) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var hostname, endpoint;\n                return tslib_1.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, input.regionInfoProvider(region)];\n                        case 1:\n                            hostname = ((_a.sent()) || {}).hostname;\n                            if (!hostname) {\n                                throw new Error(\"Cannot resolve hostname from client config\");\n                            }\n                            endpoint = input.urlParser((tls ? \"https:\" : \"http:\") + \"//\" + hostname);\n                            return [2 /*return*/, endpoint];\n                    }\n                });\n            }); });\n        };\n    return tslib_1.__assign(tslib_1.__assign({}, input), { endpoint: endpoint,\n        tls: tls });\n}\nexports.resolveEndpointsConfig = resolveEndpointsConfig;\n"},"sourceMaps":{"js":{"version":3,"file":"EndpointsConfig.js","sourceRoot":"","sources":["../../src/EndpointsConfig.ts"],"names":[],"mappings":";;;;AAEA,SAAgB,iBAAiB,CAC/B,QAAiD,EACjD,SAAqB;IAErB,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,IAAM,aAAW,GAAG,OAAO,CAAC,OAAO,CAAC,SAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC1D,OAAO,cAAM,OAAA,aAAW,EAAX,CAAW,CAAC;KAC1B;SAAM,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QACvC,IAAM,aAAW,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC9C,OAAO,cAAM,OAAA,aAAW,EAAX,CAAW,CAAC;KAC1B;IACD,OAAO,QAAS,CAAC;AACnB,CAAC;AAZD,8CAYC;AAqBD,SAAgB,sBAAsB,CACpC,KAAoD;IADtD,iBAoBC;IAjBC,IAAM,GAAG,GAAG,KAAK,CAAC,GAAG,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC;IACvD,IAAM,QAAQ,GAAuB,KAAK,CAAC,QAAQ;QACjD,CAAC,CAAC,iBAAiB,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,SAAS,CAAC;QACpD,CAAC,CAAC;YACE,OAAA,KAAK,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,UAAO,MAAM;;;;gCACZ,qBAAM,KAAK,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAAA;;4BAAnD,QAAQ,GAAG,CAAC,CAAC,SAAsC,CAAC,IAAK,EAAiB,CAAC,CAAC,QAAQ;4BAC1F,IAAI,CAAC,QAAQ,EAAE;gCACb,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;6BAC/D;4BACK,QAAQ,GAAG,KAAK,CAAC,SAAS,CAAC,CAAG,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,WAAK,QAAU,CAAC,CAAC;4BAC7E,sBAAO,QAAQ,EAAC;;;iBACjB,CAAC;QAPF,CAOE,CAAC;IACT,6CACK,KAAK,KACR,QAAQ,UAAA;QACR,GAAG,KAAA,IACH;AACJ,CAAC;AApBD,wDAoBC","sourcesContent":["import { Endpoint, Provider, RegionInfo,RegionInfoProvider, UrlParser } from \"@aws-sdk/types\";\n\nexport function normalizeEndpoint(\n  endpoint?: string | Endpoint | Provider<Endpoint>,\n  urlParser?: UrlParser\n): Provider<Endpoint> {\n  if (typeof endpoint === \"string\") {\n    const promisified = Promise.resolve(urlParser!(endpoint));\n    return () => promisified;\n  } else if (typeof endpoint === \"object\") {\n    const promisified = Promise.resolve(endpoint);\n    return () => promisified;\n  }\n  return endpoint!;\n}\n\nexport interface EndpointsInputConfig {\n  /**\n   * The fully qualified endpoint of the webservice. This is only required when using a custom endpoint (for example, when using a local version of S3).\n   */\n  endpoint?: string | Endpoint | Provider<Endpoint>;\n\n  /**\n   * Whether TLS is enabled for requests.\n   */\n  tls?: boolean;\n}\ninterface PreviouslyResolved {\n  regionInfoProvider: RegionInfoProvider;\n  urlParser: UrlParser;\n  region: Provider<string>;\n}\nexport interface EndpointsResolvedConfig extends Required<EndpointsInputConfig> {\n  endpoint: Provider<Endpoint>;\n}\nexport function resolveEndpointsConfig<T>(\n  input: T & EndpointsInputConfig & PreviouslyResolved\n): T & EndpointsResolvedConfig {\n  const tls = input.tls === undefined ? true : input.tls;\n  const endpoint: Provider<Endpoint> = input.endpoint\n    ? normalizeEndpoint(input.endpoint, input.urlParser)\n    : () =>\n        input.region().then(async (region) => {\n          const hostname = ((await input.regionInfoProvider(region)) || ({} as RegionInfo)).hostname;\n          if (!hostname) {\n            throw new Error(\"Cannot resolve hostname from client config\");\n          }\n          const endpoint = input.urlParser(`${tls ? \"https:\" : \"http:\"}//${hostname}`);\n          return endpoint;\n        });\n  return {\n    ...input,\n    endpoint,\n    tls,\n  };\n}\n"]}},"error":null,"hash":"505ed9a67944939a77dc3b19434ff1cd","cacheData":{"env":{}}}