{"id":"node_modules/@aws-sdk/smithy-client/dist/cjs/split-every.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/smithy-client/package.json","includedInParent":true,"mtime":1599668814074}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.splitEvery = void 0;\n/**\n * Given an input string, splits based on the delimiter after a given\n * number of delimiters has been encountered.\n *\n * @param value The input string to split.\n * @param delimiter The delimiter to split on.\n * @param numDelimiters The number of delimiters to have encountered to split.\n */\nfunction splitEvery(value, delimiter, numDelimiters) {\n    // Fail if we don't have a clear number to split on.\n    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {\n        throw new Error(\"Invalid number of delimiters (\" + numDelimiters + \") for splitEvery.\");\n    }\n    var segments = value.split(delimiter);\n    // Short circuit extra logic for the simple case.\n    if (numDelimiters === 1) {\n        return segments;\n    }\n    var compoundSegments = [];\n    var currentSegment = \"\";\n    for (var i = 0; i < segments.length; i++) {\n        if (currentSegment === \"\") {\n            // Start a new segment.\n            currentSegment = segments[i];\n        }\n        else {\n            // Compound the current segment with the delimiter.\n            currentSegment += delimiter + segments[i];\n        }\n        if ((i + 1) % numDelimiters === 0) {\n            // We encountered the right number of delimiters, so add the entry.\n            compoundSegments.push(currentSegment);\n            // And reset the current segment.\n            currentSegment = \"\";\n        }\n    }\n    // Handle any leftover segment portion.\n    if (currentSegment !== \"\") {\n        compoundSegments.push(currentSegment);\n    }\n    return compoundSegments;\n}\nexports.splitEvery = splitEvery;\n"},"sourceMaps":{"js":{"version":3,"file":"split-every.js","sourceRoot":"","sources":["../../src/split-every.ts"],"names":[],"mappings":";;;AAAA;;;;;;;GAOG;AACH,SAAgB,UAAU,CAAC,KAAa,EAAE,SAAiB,EAAE,aAAqB;IAChF,oDAAoD;IACpD,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,aAAa,CAAC,EAAE;QAC1D,MAAM,IAAI,KAAK,CAAC,gCAAgC,GAAG,aAAa,GAAG,mBAAmB,CAAC,CAAC;KACzF;IAED,IAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACxC,iDAAiD;IACjD,IAAI,aAAa,KAAK,CAAC,EAAE;QACvB,OAAO,QAAQ,CAAC;KACjB;IAED,IAAM,gBAAgB,GAAkB,EAAE,CAAC;IAC3C,IAAI,cAAc,GAAG,EAAE,CAAC;IACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,IAAI,cAAc,KAAK,EAAE,EAAE;YACzB,uBAAuB;YACvB,cAAc,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;SAC9B;aAAM;YACL,mDAAmD;YACnD,cAAc,IAAI,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,KAAK,CAAC,EAAE;YACjC,mEAAmE;YACnE,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACtC,iCAAiC;YACjC,cAAc,GAAG,EAAE,CAAC;SACrB;KACF;IAED,uCAAuC;IACvC,IAAI,cAAc,KAAK,EAAE,EAAE;QACzB,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;KACvC;IAED,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AArCD,gCAqCC","sourcesContent":["/**\n * Given an input string, splits based on the delimiter after a given\n * number of delimiters has been encountered.\n *\n * @param value The input string to split.\n * @param delimiter The delimiter to split on.\n * @param numDelimiters The number of delimiters to have encountered to split.\n */\nexport function splitEvery(value: string, delimiter: string, numDelimiters: number): Array<string> {\n  // Fail if we don't have a clear number to split on.\n  if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {\n    throw new Error(\"Invalid number of delimiters (\" + numDelimiters + \") for splitEvery.\");\n  }\n\n  const segments = value.split(delimiter);\n  // Short circuit extra logic for the simple case.\n  if (numDelimiters === 1) {\n    return segments;\n  }\n\n  const compoundSegments: Array<string> = [];\n  let currentSegment = \"\";\n  for (let i = 0; i < segments.length; i++) {\n    if (currentSegment === \"\") {\n      // Start a new segment.\n      currentSegment = segments[i];\n    } else {\n      // Compound the current segment with the delimiter.\n      currentSegment += delimiter + segments[i];\n    }\n\n    if ((i + 1) % numDelimiters === 0) {\n      // We encountered the right number of delimiters, so add the entry.\n      compoundSegments.push(currentSegment);\n      // And reset the current segment.\n      currentSegment = \"\";\n    }\n  }\n\n  // Handle any leftover segment portion.\n  if (currentSegment !== \"\") {\n    compoundSegments.push(currentSegment);\n  }\n\n  return compoundSegments;\n}\n"]}},"error":null,"hash":"707c2629c8fceaad1e0e4eaceb76a13c","cacheData":{"env":{}}}