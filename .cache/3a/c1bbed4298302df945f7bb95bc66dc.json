{"id":"node_modules/@aws-sdk/middleware-retry/dist/cjs/defaultRetryQuota.js","dependencies":[{"name":"/Users/spittela/code/giphlify/package.json","includedInParent":true,"mtime":1599683869183},{"name":"/Users/spittela/code/giphlify/.babelrc","includedInParent":true,"mtime":1599669969128},{"name":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-retry/package.json","includedInParent":true,"mtime":1599668814020},{"name":"./constants","loc":{"line":4,"column":26},"parent":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-retry/dist/cjs/defaultRetryQuota.js","resolved":"/Users/spittela/code/giphlify/node_modules/@aws-sdk/middleware-retry/dist/cjs/constants.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaultRetryQuota = void 0;\nvar constants_1 = require(\"./constants\");\nexports.getDefaultRetryQuota = function (initialRetryTokens) {\n    var MAX_CAPACITY = initialRetryTokens;\n    var availableCapacity = initialRetryTokens;\n    var getCapacityAmount = function (error) { return (error.name === \"TimeoutError\" ? constants_1.TIMEOUT_RETRY_COST : constants_1.RETRY_COST); };\n    var hasRetryTokens = function (error) { return getCapacityAmount(error) <= availableCapacity; };\n    var retrieveRetryTokens = function (error) {\n        if (!hasRetryTokens(error)) {\n            // retryStrategy should stop retrying, and return last error\n            throw new Error(\"No retry token available\");\n        }\n        var capacityAmount = getCapacityAmount(error);\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    var releaseRetryTokens = function (capacityReleaseAmount) {\n        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : constants_1.NO_RETRY_INCREMENT;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return Object.freeze({\n        hasRetryTokens: hasRetryTokens,\n        retrieveRetryTokens: retrieveRetryTokens,\n        releaseRetryTokens: releaseRetryTokens,\n    });\n};\n"},"sourceMaps":{"js":{"version":3,"file":"defaultRetryQuota.js","sourceRoot":"","sources":["../../src/defaultRetryQuota.ts"],"names":[],"mappings":";;;AAEA,yCAAiF;AAGpE,QAAA,oBAAoB,GAAG,UAAC,kBAA0B;IAC7D,IAAM,YAAY,GAAG,kBAAkB,CAAC;IACxC,IAAI,iBAAiB,GAAG,kBAAkB,CAAC;IAE3C,IAAM,iBAAiB,GAAG,UAAC,KAAe,IAAK,OAAA,CAAC,KAAK,CAAC,IAAI,KAAK,cAAc,CAAC,CAAC,CAAC,8BAAkB,CAAC,CAAC,CAAC,sBAAU,CAAC,EAAjE,CAAiE,CAAC;IAEjH,IAAM,cAAc,GAAG,UAAC,KAAe,IAAK,OAAA,iBAAiB,CAAC,KAAK,CAAC,IAAI,iBAAiB,EAA7C,CAA6C,CAAC;IAE1F,IAAM,mBAAmB,GAAG,UAAC,KAAe;QAC1C,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;YAC1B,4DAA4D;YAC5D,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;QACD,IAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAChD,iBAAiB,IAAI,cAAc,CAAC;QACpC,OAAO,cAAc,CAAC;IACxB,CAAC,CAAC;IAEF,IAAM,kBAAkB,GAAG,UAAC,qBAA8B;QACxD,iBAAiB,IAAI,qBAAqB,aAArB,qBAAqB,cAArB,qBAAqB,GAAI,8BAAkB,CAAC;QACjE,iBAAiB,GAAG,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,YAAY,CAAC,CAAC;IAChE,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC,MAAM,CAAC;QACnB,cAAc,gBAAA;QACd,mBAAmB,qBAAA;QACnB,kBAAkB,oBAAA;KACnB,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["import { SdkError } from \"@aws-sdk/smithy-client\";\n\nimport { NO_RETRY_INCREMENT, RETRY_COST, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { RetryQuota } from \"./defaultStrategy\";\n\nexport const getDefaultRetryQuota = (initialRetryTokens: number): RetryQuota => {\n  const MAX_CAPACITY = initialRetryTokens;\n  let availableCapacity = initialRetryTokens;\n\n  const getCapacityAmount = (error: SdkError) => (error.name === \"TimeoutError\" ? TIMEOUT_RETRY_COST : RETRY_COST);\n\n  const hasRetryTokens = (error: SdkError) => getCapacityAmount(error) <= availableCapacity;\n\n  const retrieveRetryTokens = (error: SdkError) => {\n    if (!hasRetryTokens(error)) {\n      // retryStrategy should stop retrying, and return last error\n      throw new Error(\"No retry token available\");\n    }\n    const capacityAmount = getCapacityAmount(error);\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  const releaseRetryTokens = (capacityReleaseAmount?: number) => {\n    availableCapacity += capacityReleaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return Object.freeze({\n    hasRetryTokens,\n    retrieveRetryTokens,\n    releaseRetryTokens,\n  });\n};\n"]}},"error":null,"hash":"640482fc48e9d0932853548bf4bc1dbb","cacheData":{"env":{}}}